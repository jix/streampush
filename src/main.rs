use futures::{Future, StreamExt};
use std::{
    fs,
    io::ErrorKind,
    net::{SocketAddr, ToSocketAddrs},
    path::PathBuf,
    sync::Arc,
};
use tracing::Instrument;

use anyhow::Result;
use structopt::StructOpt;

use crate::congestion::FixedRateConfig;

mod congestion;

/// Tunnel TCP connections over QUIC.
#[derive(StructOpt)]
enum Opt {
    Client(ClientOpt),
    Server(ServerOpt),
}

/// Lookup hostnames during argument parsing.
fn lookup_host(name: &str) -> Result<SocketAddr> {
    if let Some(first) = name.to_socket_addrs()?.next() {
        Ok(first)
    } else {
        anyhow::bail!("couldn't resolve `{}`", name);
    }
}

/// Tunnel server, accept incoming QUIC connections and forward streams as TCP connections to a
/// target host.
#[derive(StructOpt)]
struct ServerOpt {
    /// TLS certificate to use. Generates a self-signed certificate and private key when both are
    /// missing.
    #[structopt(long, default_value = "cert.der", parse(from_os_str))]
    cert: PathBuf,
    /// TLS private key to use. Generates a self-signed certificate and private key when both are
    /// missing.
    #[structopt(long, default_value = "key.der", parse(from_os_str))]
    key: PathBuf,
    /// TLS server name for the self-signed certificate to generate. Needs to match the client
    /// option, doesn't need to match any actual host names.
    #[structopt(long, default_value = "localhost")]
    name: String,
    /// Address and port to listen on for incoming QUIC connections.
    #[structopt(long, default_value = "[::]:14903")]
    listen: SocketAddr,
    /// Address (or hostname) and port to forward TCP connections to.
    #[structopt(long, default_value = "[::1]:1935", parse(try_from_str = lookup_host))]
    connect: SocketAddr,
    /// Use a fixed rate congestion controller to work around moderate packet loss or bursts of high
    /// packet loss. Rate in kbit/s.
    ///
    /// For an asymmetric connection, it is ok to only specify this for the sender whose packets are
    /// lost.
    ///
    /// WARNING: For this to work at all, the tunneled TCP connection must be inherently bandwidth
    /// limited at the source (e.g. a RTMP live stream). The specified rate should roughly match the
    /// available bandwidth and exceed the bandwidth of the tunneled data. Finding the best rate
    /// might require some trial and error.
    #[structopt(long)]
    rate: Option<u64>,
}

/// Tunnel client, accept local TCP connections and tunnel them via QUIC to the streampush server.
#[derive(StructOpt)]
struct ClientOpt {
    /// TLS certificate to trust. Usually a copy of the file generated by the server on first start.
    #[structopt(long, default_value = "cert.der", parse(from_os_str))]
    cert: PathBuf,
    /// TLS server name to expect. Needs to match the server option during certificate generation,
    /// doesn't need to match any actual host names.
    #[structopt(long, default_value = "localhost")]
    name: String,
    /// Address (or hostname) and port to connect to via QUIC.
    #[structopt(long, default_value = "[::1]:14903", parse(try_from_str = lookup_host))]
    connect: SocketAddr,
    /// Address and port to listen on for incoming TCP connections to forward.
    #[structopt(long, default_value = "[::1]:1935")]
    listen: SocketAddr,
    /// Use a fixed rate congestion controller to work around moderate packet loss or bursts of high
    /// packet loss. Rate in kbit/s.
    ///
    /// For an asymmetric connection, it is ok to only specify this for the sender whose packets are
    /// lost.
    ///
    /// WARNING: For this to work at all, the tunneled TCP connection must be inherently bandwidth
    /// limited at the source (e.g. a RTMP live stream). The specified rate should roughly match the
    /// available bandwidth and exceed the bandwidth of the tunneled data. Finding the best rate
    /// might require some trial and error.
    #[structopt(long)]
    rate: Option<u64>,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").as_deref().unwrap_or(&"info"),
        ))
        .with_writer(std::io::stderr)
        .init();

    let opt = Opt::from_args();

    match opt {
        Opt::Client(opt) => client(opt).await?,
        Opt::Server(opt) => server(opt).await?,
    }

    Ok(())
}

async fn log_error(future: impl Future<Output = Result<()>>) {
    if let Err(err) = future.await {
        tracing::error!(?err);
    }
}

async fn client(opt: ClientOpt) -> Result<()> {
    // Configure quinn QUIC client
    let mut endpoint = quinn::Endpoint::builder();
    let mut client_config = quinn::ClientConfigBuilder::default();

    let cert = fs::read(&opt.cert)?;
    let cert = quinn::Certificate::from_der(&cert)?;
    client_config.add_certificate_authority(cert)?;

    let mut client_config = client_config.build();

    // Transport configuration
    let mut transport_config = quinn::TransportConfig::default();
    transport_config.max_idle_timeout(None)?;
    if let Some(rate) = opt.rate {
        transport_config.congestion_controller_factory(FixedRateConfig {
            kbits_per_sec: rate,
        });
    }
    client_config.transport = Arc::new(transport_config);

    endpoint.default_client_config(client_config);

    // Initiate QUIC connection to server
    let (endpoint, _) = endpoint.bind(
        &if opt.connect.is_ipv4() {
            "0.0.0.0:0"
        } else {
            "[::]:0"
        }
        .parse()
        .unwrap(),
    )?;

    let new_conn = endpoint
        .connect(&opt.connect, &opt.name)?
        .await
        .map_err(|e| anyhow::anyhow!("failed to connect: {}", e))?;

    tracing::info!("connected via QUIC");

    // Listen for TCP connections to forward
    let socket = if opt.listen.is_ipv4() {
        tokio::net::TcpSocket::new_v4()?
    } else {
        tokio::net::TcpSocket::new_v6()?
    };

    socket.set_reuseaddr(true)?;
    // Limit the amount of data buffered locally
    socket.set_recv_buffer_size(1 << 15)?;
    socket.bind(opt.listen)?;

    let listener = socket.listen(1024)?;

    tracing::info!("listening for TCP connections");

    let new_conn = Arc::new(new_conn);

    let mut counter: usize = 0;

    loop {
        let (stream, peer) = listener.accept().await?;
        counter += 1;
        let id = counter;

        stream.set_nodelay(true)?;

        let new_conn = new_conn.clone();

        tokio::spawn(
            log_error(async move {
                tracing::info!(?peer, "new TCP connection");
                // Create new bidirectional QUIC stream and forward data in both directions
                let (mut quic_send, mut quic_recv) = new_conn.connection.open_bi().await?;
                tracing::info!("connected QUIC stream");

                let (mut tcp_recv, mut tcp_send) = stream.into_split();

                let quic_recv_tcp_send = tokio::spawn(
                    log_error(async move {
                        tokio::io::copy(&mut quic_recv, &mut tcp_send).await?;
                        Ok::<_, anyhow::Error>(())
                    })
                    .instrument(tracing::info_span!("QUIC->TCP"))
                    .in_current_span(),
                );

                let tcp_recv_quic_send = tokio::spawn(
                    log_error(async move {
                        tokio::io::copy(&mut tcp_recv, &mut quic_send).await?;
                        Ok::<_, anyhow::Error>(())
                    })
                    .instrument(tracing::info_span!("TCP->QUIC"))
                    .in_current_span(),
                );

                tokio::try_join!(quic_recv_tcp_send, tcp_recv_quic_send)?;

                tracing::info!("closed tunneled TCP<->QUIC stream");

                Ok::<_, anyhow::Error>(())
            })
            .instrument(tracing::info_span!("connection", id)),
        );
    }
}

async fn server(opt: ServerOpt) -> Result<()> {
    // Read or generate key pair
    let (cert, key) = match (fs::read(&opt.cert), fs::read(&opt.key)) {
        (Ok(cert), Ok(key)) => (cert, key),
        (Err(cert_err), Err(key_err))
            if cert_err.kind() == ErrorKind::NotFound && key_err.kind() == ErrorKind::NotFound =>
        {
            tracing::info!(
                "cert and private key not found, generating key and self-signed certificate"
            );
            let cert = rcgen::generate_simple_self_signed(vec![opt.name.clone()])?;
            let cert_der = cert.serialize_der().unwrap();
            let key = cert.serialize_private_key_der();
            fs::write(&opt.cert, &cert_der)?;
            fs::write(&opt.key, &key)?;
            (cert_der, key)
        }
        (Err(err), _) | (_, Err(err)) => {
            return Err(anyhow::Error::from(err).context(format!(
                "cannot read cert {:?} and private key {:?}",
                opt.cert, opt.key
            )))
        }
    };

    let key = quinn::PrivateKey::from_der(&key)?;
    let cert = quinn::Certificate::from_der(&cert)?;

    // Transport configuration
    let mut transport_config = quinn::TransportConfig::default();
    transport_config.max_concurrent_uni_streams(0).unwrap();
    transport_config.max_concurrent_bidi_streams(1000).unwrap();
    transport_config.max_idle_timeout(None)?;
    if let Some(rate) = opt.rate {
        transport_config.congestion_controller_factory(FixedRateConfig {
            kbits_per_sec: rate,
        });
    }
    // Server configuration
    let mut server_config = quinn::ServerConfig::default();
    server_config.transport = Arc::new(transport_config);
    let mut server_config = quinn::ServerConfigBuilder::new(server_config);
    server_config.certificate(quinn::CertificateChain::from_certs(vec![cert]), key)?;

    let mut endpoint = quinn::Endpoint::builder();
    endpoint.listen(server_config.build());

    // Listen for QUIC connections
    let (_endpoint, mut incoming) = endpoint.bind(&opt.listen)?;
    tracing::info!("listening for QUIC connections");

    let opt = Arc::new(opt);

    let mut counter: usize = 0;

    while let Some(conn) = incoming.next().await {
        counter += 1;
        let client_id = counter;
        tokio::spawn(
            handle_connection(conn, opt.clone())
                .instrument(tracing::info_span!("client", id = client_id)),
        );
    }
    Ok(())
}

async fn handle_connection(conn: quinn::Connecting, opt: Arc<ServerOpt>) -> Result<()> {
    tracing::info!(peer = ?conn.remote_address(), "new QUIC connection");

    let mut conn = conn.await?;

    let mut counter: usize = 0;

    // Listen for streams within the QUIC connection
    while let Some(stream) = conn.bi_streams.next().await {
        counter += 1;
        let stream_id = counter;

        let opt = opt.clone();
        tokio::spawn(
            log_error(async move {
                let (mut quic_send, mut quic_recv) = stream?;
                tracing::info!("new QUIC stream");

                // Connect to target via TCP and forward data in both directions
                let socket = if opt.connect.is_ipv4() {
                    tokio::net::TcpSocket::new_v4()?
                } else {
                    tokio::net::TcpSocket::new_v6()?
                };
                let stream = socket.connect(opt.connect).await?;

                tracing::info!("connected via TCP");

                stream.set_nodelay(true)?;
                let (mut tcp_recv, mut tcp_send) = stream.into_split();

                let quic_recv_tcp_send = tokio::spawn(
                    log_error(async move {
                        tokio::io::copy(&mut quic_recv, &mut tcp_send).await?;
                        Ok::<_, anyhow::Error>(())
                    })
                    .instrument(tracing::info_span!("QUIC->TCP"))
                    .in_current_span(),
                );

                let tcp_recv_quic_send = tokio::spawn(
                    log_error(async move {
                        tokio::io::copy(&mut tcp_recv, &mut quic_send).await?;
                        Ok::<_, anyhow::Error>(())
                    })
                    .instrument(tracing::info_span!("TCP->QUIC"))
                    .in_current_span(),
                );

                tokio::try_join!(quic_recv_tcp_send, tcp_recv_quic_send)?;

                tracing::info!("closed tunneled QUIC<->TCP stream");

                Ok::<_, anyhow::Error>(())
            })
            .instrument(tracing::info_span!("stream", id = stream_id))
            .in_current_span(),
        );
    }

    Ok(())
}
