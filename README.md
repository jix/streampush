# Streampush

Tunnel TCP connections over QUIC with an optional fixed rate congestion controller.

Consists of a server and a client. All the difficult parts are handled by the excellent [Quinn library].

[Quinn library]: https://github.com/quinn-rs/quinn

## Server

The server listens for QUIC connections and for every stream within each QUIC connection, forwards data to and from a target host via a TCP connection.

```
$ streampush server --help
Tunnel server, accept incoming QUIC connections and forward streams as TCP connections to a target host

USAGE:
    streampush server [OPTIONS]

FLAGS:
    -h, --help
            Prints help information

    -V, --version
            Prints version information


OPTIONS:
        --cert <cert>
            TLS certificate to use. Generates a self-signed certificate and private key when both are missing [default:
            cert.der]
        --connect <connect>
            Address (or hostname) and port to forward TCP connections to [default: [::1]:1935]

        --key <key>
            TLS private key to use. Generates a self-signed certificate and private key when both are missing [default:
            key.der]
        --listen <listen>
            Address and port to listen on for incoming QUIC connections [default: [::]:14903]

        --name <name>
            TLS server name for the self-signed certificate to generate. Needs to match the client option, doesn't need
            to match any actual host names [default: localhost]
        --rate <rate>
            Use a fixed rate congestion controller to work around moderate packet loss or bursts of high packet loss.
            Rate in kbit/s.

            For an asymmetric connection, it is ok to only specify this for the sender whose packets are lost.

            WARNING: For this to work at all, the tunneled TCP connection must be inherently bandwidth limited at the
            source (e.g. a RTMP live stream). The specified rate should roughly match the available bandwidth and exceed
            the bandwidth of the tunneled data. Finding the best rate might require some trial and error.
```

##  Client

The client connects to the server via QUIC and listens for (usally local) TCP connections connections. For every TCP connection, it opens a QUIC stream and forwards data to and from the TCP connection.

```
$ streampush client --help
streampush-client 0.1.0
Tunnel client, accept local TCP connections and tunnel them via QUIC to the streampush server

USAGE:
    streampush client [OPTIONS]

FLAGS:
    -h, --help
            Prints help information

    -V, --version
            Prints version information


OPTIONS:
        --cert <cert>
            TLS certificate to trust. Usually a copy of the file generated by the server on first start [default:
            cert.der]
        --connect <connect>
            Address (or hostname) and port to connect to via QUIC [default: [::1]:14903]

        --listen <listen>
            Address and port to listen on for incoming TCP connections to forward [default: [::1]:1935]

        --name <name>
            TLS server name to expect. Needs to match the server option during certificate generation, doesn't need to
            match any actual host names [default: localhost]
        --rate <rate>
            Use a fixed rate congestion controller to work around moderate packet loss or bursts of high packet loss.
            Rate in kbit/s.

            For an asymmetric connection, it is ok to only specify this for the sender whose packets are lost.

            WARNING: For this to work at all, the tunneled TCP connection must be inherently bandwidth limited at the
            source (e.g. a RTMP live stream). The specified rate should roughly match the available bandwidth and exceed
            the bandwidth of the tunneled data. Finding the best rate might require some trial and error.
```

## Security

Currently there is no real authentication. While the QUIC stream between client and server is protected by TLS, the incoming and outgoing TCP connections are not, unless you tunnel a protocol which itself uses TLS (e.g. RTMPS).

By default the server generates a self-signed key pair and the client needs a copy of the public key to trust it. The server doesn't authenticate the client at all.

## Example Use Case

My home internet has around 1% packet loss on average and occasional bursts of 10% packet loss or more. This makes RTMP streaming to services like YouTube or Twitch unusable. The bursts cause TCP congestion control to limit the outgoing data rate to way below the required bandwidth for the RTMP stream and the overall packet loss makes the recovery too slow to avoid buffering.

To work around this, I use Streampush to tunnel the RTMP stream to a cloud server I rented. This means the traffic flows like this:

```
              [OBS @ home]
                   ^
                   |
              RTMP via TCP   (local connection)
                   |
                   v
       [streampush client @ home]
                   ^
                   |
              QUIC tunnel    (packet loss)
                   |
                   v
   [streampush server @ cloud server]
                   ^
                   |
              RTMP via TCP   (good connection)
                   |
                   v
 [ingestion server @ streaming provider]
```

For Streampush to be able to reliably get the RTMP data to the cloud server, I need to specify the fixed rate congestion controller (`--rate`) at the Streampush client. As rate I specify the upstream bandwidth of my home connection. (It might be worth trying slightly smaller or larger rates i.e. 0.8x to 1.2x the upstream bandwidth.) I then use a stream bitrate for OBS that is significantly lower (about half my upstream bandwidth).

Note that even during bursts of packet loss, I get a low ping (20ms average) to my cloud server, when doing a UDP based speed test, I also still get most of my theoretical upstream bandwidth. If your connection has high packet loss _and_ a really high average round trip time,Sstreampush will probably not help. Streampush still uses retransmissions (done automatically by QUIC), while handling such conditions would require forward error correction.

On my cloud server I use the following command:

```
streampush server --connect a.rtmp.youtube.com:1935 --listen 0.0.0.0:14903
```

On the first run, it generates a `cert.der` and a `key.der` file in the current directory. The client needs a copy of that `cert.der` file in the current directory.

The `--connect` argument is the hostname of whatever RTMP URL your streaming provider tells you (e.g. `rtmp://a.rtmp.youtube.com/live2`) together with the default RTMP port of 1935.

I specify `--listen` with `0.0.0.0:14903` instead of the default of `[::]:14903` to force IPv4, because reliably transmitting data isn't the only thing my ISP fails at.

On my machine at home I then, after starting the server, run
```
streampush client --connect my.server:14903 --rate 10000
```

Finally I specify `rtmp://[::1]/live2` as RTMP server on OBS, i.e. I replace the hostname with the IPv6 loopback address but keep the rest of the URL.

## Compiling

Clone the repository using `--recursive` to get the required git version of Quinn:

```
git clone https://github.com/jix/streampush --recursive
```

Make sure you have a working Rust setup, see e.g. [rustup.rs] for how.

[rustup.rs]: https://rustup.rs/

Compile with:
```
cargo build --release
```

The resulting combined client and server binary is in `target/release/streampush`.

If you want to build a statically linked version, add `--target=x86_64-unknown-linux-musl` (or similar for different platforms) to `cargo build`. Missing targets can be installed with `rustup target add x86_64-unknown-linux-musl`. The resulting binary is `target/x86_64-unknown-linux-musl/release/streampush`.

